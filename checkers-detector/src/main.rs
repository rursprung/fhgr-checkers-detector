//! This application can detect and identify checkers pieces on a board generated by
//! the accompanying `board-generator`.

#![forbid(unsafe_code)]
#![deny(warnings)]
#![deny(missing_docs)]
#![deny(missing_debug_implementations)]
#![deny(unused)]

mod board_extractor;
mod camera_control;
mod detector;

use crate::board_extractor::{BoardExtractorError, extract_board, Config as BoardExtractorConfig};
use crate::camera_control::Esp32Cam;
use crate::detector::{DebugFieldConfig, Detector, Config as DetectorConfig, CalibratedDetector};
use DetectorError::*;
use clap::Parser;
use log::{debug, warn};
use opencv::{
    core::{Size, ToInputArray, ToOutputArray},
    highgui::{imshow, wait_key, wait_key_def},
    imgcodecs::imread_def,
    imgproc::{INTER_LINEAR, resize},
    prelude::*,
    videoio::VideoCapture,
};
use std::fmt::{Display, Formatter};
use url::Url;

/// Defines a fixed length for the edge of a field in the rectified image
const PX_PER_FIELD_EDGE: u8 = 128;

#[derive(Copy, Clone, Debug, clap::ValueEnum)]
enum CameraType {
    Esp32Cam,
}

#[derive(Debug, Clone, clap::Args)]
#[group(required = true, multiple = false)]
struct InputConfig {
    /// Defines an image as input. Either this or a video feed _must_ be specified.
    #[arg(short, long)]
    image_input: Option<String>,
    /// Defines a video feed as input. Either this or a static image _must_ be specified.
    #[arg(short, long)]
    video_input: Option<String>,
}

#[derive(Debug, Clone, clap::Parser)]
struct Config {
    /// The number of fields per row & column. Defines an nâœ•n board.
    #[arg(short, long, default_value = "8")]
    num_fields_per_line: u8,
    /// Defines the input to be used.
    #[clap(flatten)]
    input: InputConfig,
    /// The type of the camera which is being accessed.
    #[arg(short, long, value_enum, requires = "video_input")]
    camera_type: Option<CameraType>,
    /// If specified, additional information about the processing of the specified field is shown.
    /// Either specify 'all' or a field position (e.g. 'A1')
    #[cfg(feature = "show_debug_screens")]
    #[arg(long)]
    debug_field: Option<String>,
}

impl Config {
    fn debug_field(&self) -> Result<DebugFieldConfig> {
        #[cfg(not(feature = "show_debug_screens"))]
        return Ok(DebugFieldConfig::None);

        #[cfg(feature = "show_debug_screens")]
        {
            use crate::detector::FieldPosition;
            let debug_field = self.debug_field.as_ref().map(|s| s.to_uppercase());
            match debug_field {
                None => Ok(DebugFieldConfig::None),
                Some(s) if s == "ALL" => Ok(DebugFieldConfig::All),
                Some(ref s) => Ok(DebugFieldConfig::Specific(FieldPosition::try_from_str(
                    &s,
                    self.num_fields_per_line,
                )?)),
            }
        }
    }
}

#[derive(Debug)]
enum DetectorError {
    UrlParseError(url::ParseError),
    UrlMustBeBaseUrl(String, String),
    ImageAcquisitionFailure(Option<opencv::Error>),
    OtherOpenCVError(opencv::Error),
    BoardNotFound,
    InternalDetectionError(detector::DetectorError),
}

impl Display for DetectorError {
    fn fmt(&self, f: &mut Formatter<'_>) -> std::fmt::Result {
        match self {
            UrlParseError(_) => write!(f, "Url parse error"),
            UrlMustBeBaseUrl(url, expected_base_url) => write!(
                f,
                "Camera URLs do not match! expected {} but got {}",
                expected_base_url, url
            ),
            ImageAcquisitionFailure(_) => write!(f, "image acquisition failed"),
            OtherOpenCVError(_) => write!(f, "Generic OpenCV Error"),
            BoardNotFound => write!(
                f,
                "Board not found in image. Are all aruco markers in view?"
            ),
            InternalDetectionError(_) => write!(f, "internal detection error"),
        }
    }
}

impl std::error::Error for DetectorError {
    fn source(&self) -> Option<&(dyn std::error::Error + 'static)> {
        match self {
            UrlParseError(e) => Some(e),
            ImageAcquisitionFailure(Some(e)) => Some(e),
            OtherOpenCVError(e) => Some(e),
            InternalDetectionError(e) => Some(e),
            _ => None,
        }
    }
}

impl From<url::ParseError> for DetectorError {
    fn from(e: url::ParseError) -> Self {
        UrlParseError(e)
    }
}

impl From<BoardExtractorError> for DetectorError {
    fn from(e: BoardExtractorError) -> Self {
        use crate::board_extractor::BoardExtractorError::*;
        match e {
            OpenCVError(e) => OtherOpenCVError(e),
        }
    }
}

impl From<detector::DetectorError> for DetectorError {
    fn from(e: detector::DetectorError) -> Self {
        use detector::DetectorError::*;
        match e {
            OpenCVError(e) => OtherOpenCVError(e),
            e => InternalDetectionError(e),
        }
    }
}

/// Default to [`OtherOpenCVError`] unless `map_err` is used explicitly.
impl From<opencv::Error> for DetectorError {
    fn from(e: opencv::Error) -> Self {
        OtherOpenCVError(e)
    }
}

type Result<T> = std::result::Result<T, DetectorError>;

/// Handle an individual frame.
fn handle_frame<M>(frame: &M, detector: &CalibratedDetector, config: &Config) -> Result<()>
where
    M: MatTrait + ToOutputArray + ToInputArray,
{
    let board = extract_board(
        frame,
        &BoardExtractorConfig {
            num_fields_per_line: config.num_fields_per_line,
            px_per_field_edge: PX_PER_FIELD_EDGE,
        },
    )?;
    if board.is_none() {
        warn!("failed to find board! skipping frame");
        return Err(BoardNotFound);
    }
    let board = board.unwrap();

    let result = detector.detect_pieces(&board)?;

    let mut out = Mat::default();
    resize(&board, &mut out, Size::default(), 0.5, 0.5, INTER_LINEAR)?;
    imshow("board", &out)?;

    debug!("{}", result);

    Ok(())
}

/// Tries to open the specified video input and stream it while it lasts.
fn handle_video_input(detector: &CalibratedDetector, config: &Config) -> Result<()> {
    let video_input = config.input.video_input.as_ref().unwrap();

    let video_input = match config.camera_type {
        Some(CameraType::Esp32Cam) => {
            let url = Url::parse(video_input).unwrap();
            let base_url = Url::parse(format!("http://{}", url.host().unwrap()).as_str()).unwrap();
            if url != base_url {
                return Err(UrlMustBeBaseUrl(url.to_string(), base_url.to_string()));
            }

            Esp32Cam::init(&base_url);

            let stream_url = format!("http://{}:81/stream", base_url.host().unwrap());
            stream_url
        }
        _ => video_input.to_string(),
    };

    let mut capture = match video_input.parse::<i32>() {
        Ok(i) => {
            debug!("opening ID based video capture {}", i);
            VideoCapture::new_def(i)
        }
        Err(_) => {
            debug!("opening path or URL based video capture {}", video_input);
            VideoCapture::from_file_def(&video_input)
        }
    }
    .map_err(|e| ImageAcquisitionFailure(Some(e)))?;
    if !capture
        .is_opened()
        .map_err(|e| ImageAcquisitionFailure(Some(e)))?
    {
        return Err(ImageAcquisitionFailure(None));
    }

    loop {
        let mut image = Mat::default();
        capture
            .read(&mut image)
            .map_err(|e| ImageAcquisitionFailure(Some(e)))?;

        match handle_frame(&image, &detector, config) {
            Ok(_) | Err(BoardNotFound) => {}
            Err(e) => return Err(e),
        }

        let key = wait_key(1)?;
        if key == 'q' as i32 {
            return Ok(());
        }
    }
}

fn main() -> Result<()> {
    env_logger::init();

    let config = Config::parse();
    
    let detector = Detector::new(
        DetectorConfig {
            num_fields_per_line: config.num_fields_per_line,
            px_per_field_edge: PX_PER_FIELD_EDGE,
            debug_field_config: config.debug_field()?,
        }
    );
    let detector = detector.calibrate();

    if let Some(ref image_input) = config.input.image_input {
        let image = imread_def(image_input).map_err(|e| ImageAcquisitionFailure(Some(e)))?;
        handle_frame(&image, &detector, &config)?;
        wait_key_def()?;
    } else if config.input.video_input.is_some() {
        handle_video_input(&detector, &config)?;
    } else {
        unreachable!("clap must ensure that either image_input or video_input is set!");
    }

    Ok(())
}
