//! This application can detect and identify checkers pieces on a board generated by
//! the accompanying `board-generator`.

#![forbid(unsafe_code)]
#![deny(warnings)]
#![deny(missing_docs)]
#![deny(missing_debug_implementations)]
#![deny(unused)]

use DetectorError::*;
use clap::Parser;
use opencv::{
    core::{Size, ToInputArray, ToOutputArray},
    highgui::{imshow, wait_key, wait_key_def},
    imgcodecs::imread_def,
    imgproc::{INTER_LINEAR, resize},
    prelude::*,
    videoio::VideoCapture,
};
use std::fmt::{Display, Formatter};

#[derive(Debug, Clone, clap::Args)]
#[group(required = true, multiple = false)]
struct InputConfig {
    /// Defines an image as input. Either this or a video feed _must_ be specified.
    #[arg(short, long)]
    image_input: Option<String>,
    /// Defines a video feed as input. Either this or a static image _must_ be specified.
    #[arg(short, long)]
    video_input: Option<String>,
}

#[derive(Debug, Clone, clap::Parser)]
struct Config {
    /// The number of fields per row & column. Defines an nâœ•n board.
    #[arg(short, long, default_value = "8")]
    num_fields_per_line: u8,
    /// Defines the input to be used.
    #[clap(flatten)]
    input: InputConfig,
}

#[derive(Debug)]
enum DetectorError {
    ImageAcquisitionFailure(Option<opencv::Error>),
    OtherOpenCVError(opencv::Error),
}

impl Display for DetectorError {
    fn fmt(&self, f: &mut Formatter<'_>) -> std::fmt::Result {
        match self {
            ImageAcquisitionFailure(_) => write!(f, "image acquisition failed"),
            OtherOpenCVError(_) => write!(f, "Generic OpenCV Error"),
        }
    }
}

impl std::error::Error for DetectorError {
    fn source(&self) -> Option<&(dyn std::error::Error + 'static)> {
        match self {
            ImageAcquisitionFailure(Some(e)) => Some(e),
            OtherOpenCVError(e) => Some(e),
            _ => None,
        }
    }
}

/// Default to [`OtherOpenCVError`] unless `map_err` is used explicitly.
impl From<opencv::Error> for DetectorError {
    fn from(e: opencv::Error) -> Self {
        OtherOpenCVError(e)
    }
}

type Result<T> = std::result::Result<T, DetectorError>;

/// Handle an individual frame.
fn handle_frame<M>(frame: &M, _config: &Config) -> Result<()>
where
    M: MatTrait + ToOutputArray + ToInputArray,
{
    let mut out = Mat::default();
    resize(frame, &mut out, Size::default(), 0.5, 0.5, INTER_LINEAR)?;
    imshow("board", &out)?;

    Ok(())
}

/// Tries to open the specified video input and stream it while it lasts.
fn handle_video_input(video_input: &str, config: &Config) -> Result<()> {
    let mut capture = match video_input.parse::<i32>() {
        Ok(i) => VideoCapture::new_def(i),
        Err(_) => VideoCapture::from_file_def(&video_input),
    }
    .map_err(|e| ImageAcquisitionFailure(Some(e)))?;
    if !capture
        .is_opened()
        .map_err(|e| ImageAcquisitionFailure(Some(e)))?
    {
        return Err(ImageAcquisitionFailure(None));
    }

    loop {
        let mut image = Mat::default();
        capture
            .read(&mut image)
            .map_err(|e| ImageAcquisitionFailure(Some(e)))?;

        handle_frame(&image, config)?;

        let key = wait_key(1)?;
        if key == 'q' as i32 {
            return Ok(());
        }
    }
}

fn main() -> Result<()> {
    let config = Config::parse();

    if let Some(ref image_input) = config.input.image_input {
        let image = imread_def(image_input).map_err(|e| ImageAcquisitionFailure(Some(e)))?;
        handle_frame(&image, &config)?;
        wait_key_def()?;
    } else if let Some(ref video_input) = config.input.video_input {
        handle_video_input(video_input, &config)?;
    }

    Ok(())
}
