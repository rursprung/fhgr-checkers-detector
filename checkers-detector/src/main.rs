//! This application can detect and identify checkers pieces on a board generated by
//! the accompanying `board-generator`.

#![forbid(unsafe_code)]
#![deny(warnings)]
#![deny(missing_docs)]
#![deny(missing_debug_implementations)]
#![deny(unused)]

mod board_extractor;
mod camera_control;
mod detector;
mod util;
mod viewer;

use std::error::Error;
use crate::detector::{Config as DetectorConfig, DebugFieldConfig, Detector};
use crate::viewer::{handle_single_image, handle_video_input, init_viewer};
use clap::Parser;

/// Defines a fixed length for the edge of a field in the rectified image
const PX_PER_FIELD_EDGE: u8 = 128;

/// Defines the camera which is being used. If set, specific settings will be set on the camera.
#[derive(Copy, Clone, Debug, clap::ValueEnum)]
pub enum CameraType {
    /// ESP32 CAM running the arduino CameraWebServer example
    Esp32Cam,
}

#[derive(Debug, Clone, clap::Args)]
#[group(required = true, multiple = false)]
struct InputConfig {
    /// Defines an image as input. Either this or a video feed _must_ be specified.
    #[arg(short, long)]
    image_input: Option<String>,
    /// Defines a video feed as input. Either this or a static image _must_ be specified.
    #[arg(short, long)]
    video_input: Option<String>,
}

#[derive(Debug, Clone, clap::Parser)]
struct Config {
    /// The number of fields per row & column. Defines an nâœ•n board.
    #[arg(short, long, default_value = "8")]
    num_fields_per_line: u8,
    /// Defines the input to be used.
    #[clap(flatten)]
    input: InputConfig,
    /// The type of the camera which is being accessed.
    #[arg(short, long, value_enum, requires = "video_input")]
    camera_type: Option<CameraType>,
    /// If specified, additional information about the processing of the specified field is shown.
    /// Either specify 'all' or a field position (e.g. 'A1')
    #[cfg(feature = "show_debug_screens")]
    #[arg(long)]
    debug_field: Option<String>,
}

impl Config {
    fn debug_field(&self) -> Result<DebugFieldConfig, Box<dyn Error>> {
        #[cfg(not(feature = "show_debug_screens"))]
        return Ok(DebugFieldConfig::None);

        #[cfg(feature = "show_debug_screens")]
        {
            use crate::detector::FieldPosition;
            let debug_field = self.debug_field.as_ref().map(|s| s.to_uppercase());
            match debug_field {
                None => Ok(DebugFieldConfig::None),
                Some(s) if s == "ALL" => Ok(DebugFieldConfig::All),
                Some(ref s) => Ok(DebugFieldConfig::Specific(FieldPosition::try_from_str(
                    &s,
                    self.num_fields_per_line,
                )?)),
            }
        }
    }
}

fn main() -> Result<(), Box<dyn Error>> {
    env_logger::init();

    let config = Config::parse();

    let detector = Detector::new(DetectorConfig {
        num_fields_per_line: config.num_fields_per_line,
        px_per_field_edge: PX_PER_FIELD_EDGE,
        debug_field_config: config.debug_field()?,
    });
    let detector = detector.calibrate();
    init_viewer(detector, config.num_fields_per_line, PX_PER_FIELD_EDGE);

    if let Some(ref image_input) = config.input.image_input {
        handle_single_image(image_input.as_str())?;
    } else if let Some(video_input) = config.input.video_input {
        handle_video_input(video_input.as_str(), config.camera_type)?;
    } else {
        unreachable!("clap must ensure that either image_input or video_input is set!");
    }

    Ok(())
}
